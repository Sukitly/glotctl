---
title: Translation Props
description: Track translation keys when `t` is passed as a prop to child components
---

## Overview

Glot can track translation keys when a translation function (`t`) is passed as a prop from a parent component to a child component. This is common in Next.js applications where you want to share translations across component boundaries.

## How It Works

When glot scans your codebase, it:

1. **Collects translation prop usages**: Identifies JSX elements like `<Component t={t} />` where `t` is a known translation function
2. **Tracks namespaces**: Records which namespace(s) the translation function was created with
3. **Recognizes child components**: When a child component receives `t` as a prop, glot knows which namespace(s) to use for key detection

### Example

```tsx
// page.tsx - Parent component
import { useTranslations } from 'next-intl';
import { LandingContent } from './landing-content';

export default function Page() {
  const t = useTranslations('Landing');
  return <LandingContent t={t} />;
}
```

```tsx
// landing-content.tsx - Child component
interface Props {
  t: (key: string) => string;
}

export function LandingContent({ t }: Props) {
  return (
    <div>
      <h1>{t('title')}</h1>        {/* Detected as Landing.title */}
      <p>{t('description')}</p>    {/* Detected as Landing.description */}
    </div>
  );
}
```

Glot will correctly track `Landing.title` and `Landing.description` as used keys, even though `useTranslations` is called in a different file.

## Supported Patterns

### Function Declarations

```tsx
function MyComponent({ t }: Props) {
  return <div>{t('key')}</div>;
}
```

### Arrow Functions

```tsx
const MyComponent = ({ t }: Props) => {
  return <div>{t('key')}</div>;
};
```

### Renamed Destructuring

```tsx
// Prop name is "t", but local variable is "translate"
function MyComponent({ t: translate }: Props) {
  return <div>{translate('key')}</div>;
}
```

### Default Values

```tsx
function MyComponent({ t = defaultT }: Props) {
  return <div>{t('key')}</div>;
}
```

### With Rest Parameters

```tsx
function MyComponent({ t, ...rest }: Props) {
  return <div {...rest}>{t('key')}</div>;
}
```

### Multiple Namespaces

When the same component is used from different pages with different namespaces, glot tracks all possible namespaces:

```tsx
// page-a.tsx
const t = useTranslations('PageA');
<SharedComponent t={t} />

// page-b.tsx
const t = useTranslations('PageB');
<SharedComponent t={t} />

// shared-component.tsx
function SharedComponent({ t }: Props) {
  // t('key') is tracked as both PageA.key and PageB.key
  return <div>{t('key')}</div>;
}
```

## Dynamic Keys with Relative Patterns

When using dynamic keys in components that receive `t` as a prop, use **relative patterns** in `glot-message-keys` annotations. Relative patterns start with `.` and are automatically expanded with the namespace(s) from the translation source.

```tsx
// feature-list.tsx
function FeatureList({ t, features }: Props) {
  return features.map(feature => {
    // glot-message-keys ".features.*.title"
    return <span>{t(`features.${feature.key}.title`)}</span>;
  });
}
```

If `FeatureList` is called with `t` from namespace `Landing`, the pattern `.features.*.title` expands to `Landing.features.*.title`.

### Why Use Relative Patterns?

1. **Namespace-agnostic**: The child component doesn't need to know which namespace it's operating on
2. **Multiple namespaces**: If the component is used from multiple pages, the pattern expands for all namespaces
3. **Suggested automatically**: When glot detects a dynamic key warning for a prop-based translation, the hint suggests using a relative pattern

```
warning: "template with expression"  dynamic-key
  --> ./src/components/feature-list.tsx:12:26
     |
 12 |                         {t(`features.${key}.title`)}
     |                          ^
     = hint: add `{/* glot-message-keys ".features.*.title" */}` to declare expected keys
```

## Translation Methods

The following translation methods are also supported for prop-based translations:

```tsx
function MyComponent({ t }: Props) {
  // All of these are tracked correctly
  const raw = t.raw('htmlContent');
  const rich = t.rich('richText', { bold: (chunks) => <b>{chunks}</b> });
  const markup = t.markup('markupText');
}
```

## Limitations

### Non-destructured Props

Glot cannot track translation calls when props are not destructured:

```tsx
// NOT supported
function MyComponent(props: Props) {
  return <div>{props.t('key')}</div>;  // Not detected
}
```

**Workaround**: Use destructuring in the function signature:

```tsx
// Supported
function MyComponent({ t }: Props) {
  return <div>{t('key')}</div>;
}
```

### Nested Destructuring

Deeply nested destructuring patterns are not supported:

```tsx
// NOT supported
function MyComponent({ translations: { t } }: Props) {
  return <div>{t('key')}</div>;  // Not detected
}
```

### Component Name Matching

Glot matches components by name (e.g., `MyComponent.t`). If you have two components with the same name in different files, they will share the same namespace tracking. This is usually desirable for shared components but may cause unexpected behavior in rare cases.
