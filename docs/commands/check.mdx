---
title: glot check
description: Run i18n checks on your codebase
---

The `check` command is the core of glot. It scans your codebase for internationalization issues.

## Usage

<CodeGroup>
```bash npm
npx glot check [CHECK_TYPES...] [OPTIONS]
```

```bash pnpm
pnpm exec glot check [CHECK_TYPES...] [OPTIONS]
```

```bash yarn
yarn glot check [CHECK_TYPES...] [OPTIONS]
```

```bash bun
bunx glot check [CHECK_TYPES...] [OPTIONS]
```

</CodeGroup>

## Check Types

You can run specific checks or all checks at once:

| Type            | Description                                                                  |
| --------------- | ---------------------------------------------------------------------------- |
| `hardcoded`     | Find untranslated text in JSX/TSX files                                      |
| `missing`       | Identify translation keys used in code but missing from locale files         |
| `orphan`        | Find keys in non-primary locales not present in primary locale               |
| `untranslated`  | Find values identical to primary locale that may need translation            |
| `unused`        | Find keys in primary locale that are not used in code                        |
| `replica-lag`   | Find keys in primary locale missing from other locales                       |
| `type-mismatch` | Find type conflicts between primary and replica locales (string vs array)    |
| `unresolved`    | Find keys that cannot be statically resolved (variables, template literals)  |

<CodeGroup>
```bash npm
# Run all checks (default)
npx glot check

# Run specific checks
npx glot check hardcoded
npx glot check missing
npx glot check orphan
npx glot check untranslated
npx glot check unused
npx glot check replica-lag
npx glot check type-mismatch
npx glot check unresolved

# Run multiple specific checks
npx glot check hardcoded missing

````

```bash pnpm
# Run all checks (default)
pnpm exec glot check

# Run specific checks
pnpm exec glot check hardcoded
pnpm exec glot check missing
pnpm exec glot check orphan
pnpm exec glot check untranslated
pnpm exec glot check unused
pnpm exec glot check replica-lag
pnpm exec glot check type-mismatch
pnpm exec glot check unresolved

# Run multiple specific checks
pnpm exec glot check hardcoded missing
````

```bash yarn
# Run all checks (default)
yarn glot check

# Run specific checks
yarn glot check hardcoded
yarn glot check missing
yarn glot check orphan
yarn glot check untranslated
yarn glot check unused
yarn glot check replica-lag
yarn glot check type-mismatch
yarn glot check unresolved

# Run multiple specific checks
yarn glot check hardcoded missing
```

```bash bun
# Run all checks (default)
bunx glot check

# Run specific checks
bunx glot check hardcoded
bunx glot check missing
bunx glot check orphan
bunx glot check untranslated
bunx glot check unused
bunx glot check replica-lag
bunx glot check type-mismatch
bunx glot check unresolved

# Run multiple specific checks
bunx glot check hardcoded missing
```

</CodeGroup>

## Options

<ParamField path="--source-root" type="string">
  Override the source code root directory. Defaults to the value from configuration file.
</ParamField>

<ParamField path="--messages-root" type="string">
  Override the messages directory path. Defaults to the value from configuration file.
</ParamField>

<ParamField path="--primary-locale" type="string">
  Override the primary locale. Defaults to the value from configuration file.
</ParamField>

<ParamField path="-v, --verbose" type="boolean" default="false">
  Enable verbose output for debugging.
</ParamField>

## Examples

### Basic Check

Check the current directory for all i18n issues:

<CodeGroup>
```bash npm
npx glot check
```

```bash pnpm
pnpm exec glot check
```

```bash yarn
yarn glot check
```

```bash bun
bunx glot check
```

</CodeGroup>

### Override Source Root

Check a specific source directory:

<CodeGroup>
```bash npm
npx glot check --source-root ./src
```

```bash pnpm
pnpm exec glot check --source-root ./src
```

```bash yarn
yarn glot check --source-root ./src
```

```bash bun
bunx glot check --source-root ./src
```

</CodeGroup>

### Verbose Mode

Get detailed output including scanned files:

<CodeGroup>
```bash npm
npx glot check -v
```

```bash pnpm
pnpm exec glot check -v
```

```bash yarn
yarn glot check -v
```

```bash bun
bunx glot check -v
```

</CodeGroup>

### Check Specific Issue Types

Run only hardcoded text detection:

<CodeGroup>
```bash npm
npx glot check hardcoded
```

```bash pnpm
pnpm exec glot check hardcoded
```

```bash yarn
yarn glot check hardcoded
```

```bash bun
bunx glot check hardcoded
```

</CodeGroup>

Run hardcoded and missing key checks:

<CodeGroup>
```bash npm
npx glot check hardcoded missing
```

```bash pnpm
pnpm exec glot check hardcoded missing
```

```bash yarn
yarn glot check hardcoded missing
```

```bash bun
bunx glot check hardcoded missing
```

</CodeGroup>

## Output Format

Glot displays issues in a compiler-like format:

```
error: "Submit"  hardcoded-text
  --> ./src/components/Button.tsx:5:22
  |
5 |     return <button>Submit</button>;
  |                    ^

warning: common.oldKey  orphan-key
  --> ./messages/en.json
  |
  | Key exists in locale file but is not used in code
  |

✘ 2 problems (1 error, 1 warning)
```

### Issue Severity

| Severity | Exit Code | Description                                                       |
| -------- | --------- | ----------------------------------------------------------------- |
| Error    | 1         | Hardcoded text, missing keys, type mismatches                     |
| Warning  | 0         | Orphan keys, untranslated values, unused keys, replica-lag, unresolved keys |

## Understanding Issues

This section explains each issue type with examples and solutions.

### Hardcoded Text (`hardcoded-text`)

Hardcoded text is user-facing content that should be translated but isn't using a translation function.

<Accordion title="Example: JSX text content">

**Problem code:**

```tsx
function Button() {
  return <button>Submit</button>;
}
```

**Glot output:**

```
error: "Submit"  hardcoded-text
  --> ./src/components/Button.tsx:2:18
  |
2 |   return <button>Submit</button>;
  |                  ^
```

**Solution:**

```tsx
import { useTranslations } from 'next-intl';

function Button() {
  const t = useTranslations('common');
  return <button>{t('submit')}</button>;
}
```

Then add the key to your locale file:

```json messages/en.json
{
  "common": {
    "submit": "Submit"
  }
}
```

</Accordion>

<Accordion title="Example: Input placeholder">

**Problem code:**

```tsx
<input placeholder="Enter your email" />
```

**Glot output:**

```
error: "Enter your email"  hardcoded-text
  --> ./src/components/Form.tsx:5:8
  |
5 |   <input placeholder="Enter your email" />
  |          ^
```

**Solution:**

```tsx
<input placeholder={t('emailPlaceholder')} />
```

</Accordion>

<Accordion title="Example: Ternary expressions">

**Problem code:**

```tsx
{isLoading ? "Loading..." : "Ready"}
```

**Glot output:**

```
error: "Loading..."  hardcoded-text
  --> ./src/components/Status.tsx:3:15
  |
3 |   {isLoading ? "Loading..." : "Ready"}
  |               ^

error: "Ready"  hardcoded-text
  --> ./src/components/Status.tsx:3:31
  |
3 |   {isLoading ? "Loading..." : "Ready"}
  |                               ^
```

**Solution:**

```tsx
{isLoading ? t('loading') : t('ready')}
```

</Accordion>

<Accordion title="How to fix hardcoded text">

**Option 1: Use translation functions (Recommended)**

Replace hardcoded text with `t()` calls:

```tsx
// Before
<button>Submit</button>

// After
<button>{t('submit')}</button>
```

**Option 2: Ignore specific text patterns**

Add patterns to `ignoreTexts` in `.glotrc.json`:

```json
{
  "ignoreTexts": ["TODO", "FIXME", "N/A", "Lorem ipsum"]
}
```

**Option 3: Suppress with directive**

Use `glot-disable-next-line` for specific cases:

```tsx
{/* glot-disable-next-line */}
<code>console.log("debug")</code>
```

**Option 4: Customize checked attributes**

Only check specific attributes in `.glotrc.json`:

```json
{
  "checkedAttributes": ["placeholder", "alt", "aria-label"]
}
```

</Accordion>

<Info>
For more details on detection rules and patterns, see [Hardcoded Text Detection](/detection/hardcoded-text).
</Info>

### Missing Keys (`missing-key`)

Missing keys occur when your code references a translation key that doesn't exist in your locale files.

<Accordion title="Example: Using undefined key">

**Problem code:**

```tsx
function WelcomeBanner() {
  const t = useTranslations('home');
  return <h1>{t('welcomeMessage')}</h1>;
}
```

**Locale file (missing the key):**

```json messages/en.json
{
  "home": {
    "title": "Home"
    // "welcomeMessage" is missing!
  }
}
```

**Glot output:**

```
error: home.welcomeMessage  missing-key
  --> ./src/components/WelcomeBanner.tsx:3
  |
  | Translation key "home.welcomeMessage" is used but not defined in messages/en.json
  |
```

**Solution:**

Add the missing key to your locale file:

```json messages/en.json
{
  "home": {
    "title": "Home",
    "welcomeMessage": "Welcome to our site!"
  }
}
```

</Accordion>

<Accordion title="Example: Typo in key name">

**Problem code:**

```tsx
// Typo: "cancle" instead of "cancel"
<button>{t('cancle')}</button>
```

**Glot output:**

```
error: common.cancle  missing-key
  --> ./src/components/Form.tsx:8
  |
  | Translation key "common.cancle" is used but not defined in messages/en.json
  |
```

**Solution:**

Fix the typo in your code:

```tsx
<button>{t('cancel')}</button>
```

</Accordion>

<Accordion title="How to fix missing keys">

**Option 1: Add the key to locale files (Most common)**

```json messages/en.json
{
  "namespace": {
    "yourKey": "Your translation"
  }
}
```

**Option 2: Fix typos in code**

Check for misspelled keys and correct them.

**Option 3: Handle dynamic keys**

For dynamic keys that can't be statically analyzed, declare them explicitly:

```tsx
// glot-message-keys "items.book", "items.video", "items.audio"
return <span>{t(`items.${item.type}`)}</span>;
```

Or use glob patterns:

```tsx
// glot-message-keys "items.*"
return <span>{t(`items.${item.type}`)}</span>;
```

**Option 4: Use `glot fix` to auto-insert declarations**

Run the fix command to automatically insert `glot-message-keys` comments:

```bash
npx glot fix --apply
```

This analyzes your template literal keys and inserts appropriate patterns. See [glot fix](/commands/fix) for details.

</Accordion>

<Info>
For more details on dynamic keys and namespace handling, see [Missing Keys Detection](/detection/missing-keys).
</Info>

### Orphan Keys (`orphan-key`)

Orphan keys are translations that exist in non-primary locale files but are not present in the primary locale. This typically indicates a synchronization issue between locales.

<Accordion title="Example: Key in replica locale not in primary">

**Primary locale (en.json):**

```json messages/en.json
{
  "common": {
    "submit": "Submit"
  }
}
```

**Non-primary locale with extra key:**

```json messages/es.json
{
  "common": {
    "submit": "Enviar",
    "legacyText": "Texto antiguo"  // Not in primary locale
  }
}
```

**Glot output:**

```
warning: common.legacyText  orphan-key
  --> ./messages/es.json
  |
  | Key exists in non-primary locale but not in primary locale (en)
  |
```

</Accordion>

<Accordion title="How to fix orphan keys">

**Option 1: Add to primary locale (Recommended)**

If the key should exist, add it to the primary locale:

```json messages/en.json
{
  "common": {
    "submit": "Submit",
    "legacyText": "Legacy Text"
  }
}
```

**Option 2: Remove from non-primary locale**

If the key is truly unused, remove it from the replica locale:

```bash
# Use glot clean to remove orphan keys
npx glot clean --apply
```

**Option 3: Accept the warning**

Orphan keys don't cause build failures, so you can accept them temporarily while working on synchronization.

</Accordion>

<Info>
For more details on orphan key types and cleanup, see [Orphan Keys Detection](/detection/orphan-keys).
</Info>

### Untranslated Values (`untranslated`)

Untranslated values are translations in non-primary locales that are identical to the primary locale, possibly indicating they haven't been translated yet.

<Accordion title="Example: Same value as primary locale">

**Primary locale:**

```json messages/en.json
{
  "common": {
    "submit": "Submit",
    "cancel": "Cancel"
  }
}
```

**Non-primary locale with untranslated values:**

```json messages/zh.json
{
  "common": {
    "submit": "Submit",
    "cancel": "Cancel"
  }
}
```

**Glot output:**

```
warning: "Common.submit"  untranslated
  --> ./messages/en.json:3:0
  = note: ("Submit") identical in: zh
  = used: (no usages found)

warning: "Common.cancel"  untranslated
  --> ./messages/en.json:4:0
  = note: ("Cancel") identical in: zh
  = used: (no usages found)
```

**Solution:**

Translate the values:

```json messages/zh.json
{
  "common": {
    "submit": "提交",
    "cancel": "取消"
  }
}
```

</Accordion>

<Accordion title="How to fix untranslated values">

**Option 1: Translate the values (Recommended)**

Update the non-primary locale files with proper translations.

**Option 2: Accept the warning**

Some values legitimately remain the same across locales (brand names, technical terms). In these cases, you can safely ignore the warning since it doesn't cause build failures.

</Accordion>

<Info>
For more details on untranslated detection, see [Untranslated Values Detection](/detection/untranslated).
</Info>

### Unused Keys (`unused-key`)

Unused keys are translations defined in your primary locale file but never referenced in your code.

<Accordion title="Example: Unused translation in primary locale">

**Primary locale with unused key:**

```json messages/en.json
{
  "common": {
    "submit": "Submit",
    "oldButtonText": "Click Me"  // Never used in code
  }
}
```

**Glot output:**

```
warning: common.oldButtonText  unused-key
  --> ./messages/en.json
  |
  | Key exists in primary locale but is not used in code
  |
```

</Accordion>

<Accordion title="How to fix unused keys">

**Option 1: Remove with `glot clean` (Recommended)**

Preview unused keys:

```bash
npx glot clean
```

Remove them:

```bash
npx glot clean --apply
```

**Option 2: Use the key in code**

If the key should be used, add it to your code:

```tsx
<button>{t('oldButtonText')}</button>
```

**Option 3: Keep intentionally**

If you're keeping keys for future use, you can accept the warnings (they don't fail builds).

</Accordion>

<Warning>
If your code uses dynamic translation keys, glot cannot determine if a key is truly unused. In this case, `clean` will refuse to run to prevent accidental deletion. Use `glot-message-keys` to declare dynamic keys explicitly.
</Warning>

<Info>
For more details on unused key detection, see [Unused Keys Detection](/detection/unused-keys).
</Info>

### Replica Lag (`replica-lag`)

Replica lag occurs when keys exist in the primary locale but are missing from other locales, indicating incomplete translations.

<Accordion title="Example: Missing translations in replica locales">

**Primary locale (en.json):**

```json messages/en.json
{
  "common": {
    "submit": "Submit",
    "newFeature": "New Feature"
  }
}
```

**Non-primary locale missing keys:**

```json messages/zh.json
{
  "common": {
    "submit": "提交"
    // "newFeature" is missing!
  }
}
```

**Glot output:**

```
warning: common.newFeature  replica-lag
  --> ./messages/en.json
  |
  | Key exists in primary locale (en) but is missing from: zh
  |
```

</Accordion>

<Accordion title="How to fix replica lag">

**Option 1: Add missing translations (Recommended)**

Add the missing keys to all replica locales:

```json messages/zh.json
{
  "common": {
    "submit": "提交",
    "newFeature": "新功能"
  }
}
```

**Option 2: Accept the warning**

If you're still working on translations, you can accept these warnings temporarily. They don't cause build failures.

</Accordion>

<Info>
For more details on replica lag detection, see [Replica Lag Detection](/detection/replica-lag).
</Info>

### Type Mismatch (`type-mismatch`)

Type mismatches occur when the same key has different value types across locales (e.g., string in one locale, array in another). This causes runtime errors.

<Accordion title="Example: String vs array type conflict">

**Primary locale (en.json):**

```json messages/en.json
{
  "items": ["Apple", "Banana", "Orange"]  // Array
}
```

**Non-primary locale with wrong type:**

```json messages/zh.json
{
  "items": "苹果, 香蕉, 橙子"  // String - WRONG!
}
```

**Glot output:**

```
error: items  type-mismatch
  --> ./messages/en.json
  |
  | Type mismatch: primary locale has array, but zh has string
  |
```

</Accordion>

<Accordion title="How to fix type mismatches">

**Solution: Ensure consistent types across all locales**

Update the replica locale to use the same type:

```json messages/zh.json
{
  "items": ["苹果", "香蕉", "橙子"]  // Now an array like primary
}
```

Type mismatches will cause your application to crash at runtime, so these are reported as errors.

</Accordion>

<Info>
For more details on type mismatch detection, see [Type Mismatch Detection](/detection/type-mismatch).
</Info>

### Unresolved Keys (`unresolved-key`)

Unresolved keys are translation keys that cannot be statically analyzed because they use variables or template literals with dynamic expressions.

<Accordion title="Example: Dynamic keys that cannot be resolved">

**Problem code:**

```tsx
// Variable key
const key = getKeyName();
<button>{t(key)}</button>

// Template literal with expression
<button>{t(`status.${statusCode}`)}</button>

// Computed property
<span>{t(keys[index])}</span>
```

**Glot output:**

```
warning: (unresolved)  unresolved-key
  --> ./src/components/Button.tsx:3:15
  |
  | Cannot statically resolve translation key (uses variable or template literal)
  |
```

</Accordion>

<Accordion title="How to fix unresolved keys">

**Option 1: Add `glot-message-keys` annotation (Recommended)**

Declare the possible keys explicitly:

```tsx
// glot-message-keys "items.book", "items.video", "items.audio"
return <span>{t(`items.${item.type}`)}</span>;
```

Or use glob patterns:

```tsx
// glot-message-keys "items.*"
return <span>{t(`items.${item.type}`)}</span>;
```

**Option 2: Use `glot fix` to auto-insert annotations**

Run the fix command to automatically analyze and insert declarations:

```bash
npx glot fix --apply
```

**Option 3: Refactor to use static keys**

If possible, use static keys with conditionals:

```tsx
// Before
<span>{t(`status.${code}`)}</span>

// After
<span>{code === 'active' ? t('status.active') : t('status.inactive')}</span>
```

</Accordion>

<Info>
For more details on unresolved key detection, see [Unresolved Keys Detection](/detection/unresolved-keys).
</Info>

## Exit Codes

| Code | Meaning                              |
| ---- | ------------------------------------ |
| 0    | No errors found (warnings may exist) |
| 1    | Errors found                         |

This makes glot suitable for CI/CD pipelines where you want to fail builds on errors.

## Verbose Output

With `-v` flag, glot shows additional information:

```
Scanning directory: ./src
Found 42 TSX/JSX files
Checking file: ./src/components/Button.tsx
Checking file: ./src/components/Form.tsx
...

error: "Submit"  hardcoded-text
  --> ./src/components/Button.tsx:5:22
```

## Related

<CardGroup cols={2}>
  <Card
    title="Hardcoded Text"
    icon="magnifying-glass"
    href="/detection/hardcoded-text"
  >
    Detect untranslated text in JSX/TSX
  </Card>
  <Card
    title="Missing Keys"
    icon="triangle-exclamation"
    href="/detection/missing-keys"
  >
    Find keys used but not defined
  </Card>
  <Card title="Orphan Keys" icon="broom" href="/detection/orphan-keys">
    Find unused translation keys in non-primary locales
  </Card>
  <Card title="Untranslated Values" icon="language" href="/detection/untranslated">
    Find values that may need translation
  </Card>
  <Card title="Unused Keys" icon="trash" href="/detection/unused-keys">
    Find keys in primary locale not used in code
  </Card>
  <Card title="Replica Lag" icon="clock" href="/detection/replica-lag">
    Find keys missing from replica locales
  </Card>
  <Card title="Type Mismatch" icon="exclamation-triangle" href="/detection/type-mismatch">
    Find type conflicts between locales
  </Card>
  <Card title="Unresolved Keys" icon="question" href="/detection/unresolved-keys">
    Find keys that cannot be statically resolved
  </Card>
  <Card title="Directives" icon="code" href="/directives">
    Suppress specific warnings
  </Card>
</CardGroup>
