//! Low-level file operations.
//!
//! Operations are the primitive building blocks for file modifications.
//! There are only two types:
//! - `InsertComment`: Insert a comment line above a source location
//! - `DeleteJsonKey`: Delete a key from a JSON file
//!
//! Each operation knows how to execute itself and preview itself.

use colored::Colorize;
use std::{fs, path::Path};
use unicode_width::UnicodeWidthStr;

use super::json_editor::JsonEditor;
use crate::core::collect::Directive;
use crate::core::collect::types::SuppressibleRule;
use crate::core::{CommentStyle, MessageContext, SourceContext};

/// A low-level file operation.
///
/// Operations are generated by Actions. Each operation can execute itself
/// (modify files) or preview itself (display what would be done).
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Operation {
    /// Insert a comment line above a source location.
    InsertComment {
        context: SourceContext,
        comment: String,
    },
    /// Delete a key from a JSON file.
    DeleteJsonKey { context: MessageContext },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OperationResult {
    Applied,
    Noop,
}

impl OperationResult {
    pub fn is_applied(self) -> bool {
        matches!(self, OperationResult::Applied)
    }
}

impl Operation {
    /// Execute this operation (modify files).
    pub fn execute(&self) -> anyhow::Result<OperationResult> {
        match self {
            Operation::InsertComment { context, comment } => {
                Self::execute_insert_comment(context, comment)
            }
            Operation::DeleteJsonKey { context } => Self::execute_delete_json_key(context),
        }
    }

    /// Preview this operation (display what would be done).
    pub fn preview(&self) {
        match self {
            Operation::InsertComment { context, comment } => {
                Self::preview_insert_comment(context, comment);
            }
            Operation::DeleteJsonKey { context } => {
                Self::preview_delete_json_key(context);
            }
        }
    }

    // ========== InsertComment implementation ==========

    fn execute_insert_comment(
        context: &SourceContext,
        comment: &str,
    ) -> anyhow::Result<OperationResult> {
        let file_path = context.file_path();
        let content = fs::read_to_string(file_path)?;

        // Detect original newline style
        let newline = if content.contains("\r\n") {
            "\r\n"
        } else {
            "\n"
        };
        let had_trailing_newline = content.ends_with(newline);

        let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();

        // Get indentation from the target line
        let target_line_idx = context.line().saturating_sub(1);
        let indentation: String = lines
            .get(target_line_idx)
            .map(|s| s.chars().take_while(|c| c.is_whitespace()).collect())
            .unwrap_or_default();

        // Merge with existing glot directive if present
        if let Some(new_directive) = parse_comment_directive(comment)
            && let Some(merge_idx) = find_mergeable_comment_line(&lines, target_line_idx)
            && let Some(existing_directive) = parse_comment_directive(&lines[merge_idx])
            && let Some(merged_comment) = merge_directives(
                &lines[merge_idx],
                comment,
                &existing_directive,
                &new_directive,
                detect_comment_style(&lines[merge_idx]).unwrap_or(context.comment_style),
            )
        {
            let existing_trimmed = lines[merge_idx].trim();
            if existing_trimmed == merged_comment.trim() {
                return Ok(OperationResult::Noop);
            }

            let merge_indentation: String = lines[merge_idx]
                .chars()
                .take_while(|c| c.is_whitespace())
                .collect();
            lines[merge_idx] = format!("{}{}", merge_indentation, merged_comment);

            let mut new_content = lines.join(newline);
            if had_trailing_newline {
                new_content.push_str(newline);
            }

            fs::write(file_path, new_content)?;
            return Ok(OperationResult::Applied);
        }

        // Insert comment above the target line
        let comment_line = format!("{}{}", indentation, comment);
        if target_line_idx <= lines.len() {
            lines.insert(target_line_idx, comment_line);
        }

        // Write back
        let mut new_content = lines.join(newline);
        if had_trailing_newline {
            new_content.push_str(newline);
        }

        fs::write(file_path, new_content)?;
        Ok(OperationResult::Applied)
    }

    fn preview_insert_comment(context: &SourceContext, comment: &str) {
        let file_path = context.file_path();
        let line = context.line();
        let col = context.col();
        let source_line = &context.source_line;

        // Clickable location
        println!("  {} {}:{}:{}", "-->".blue(), file_path, line, col);

        // Source context
        println!("     {}", "|".blue());
        println!(
            " {:>3} {} {}",
            line.to_string().blue(),
            "|".blue(),
            source_line
        );

        // Caret
        let prefix: String = source_line.chars().take(col.saturating_sub(1)).collect();
        let caret_padding = UnicodeWidthStr::width(prefix.as_str());
        println!(
            "     {} {:>padding$}{}",
            "|".blue(),
            "",
            "^".green(),
            padding = caret_padding
        );

        // Comment to be inserted
        let indentation: String = source_line
            .chars()
            .take_while(|c| c.is_whitespace())
            .collect();
        println!(
            "  {} {}{}",
            "+".green().bold(),
            indentation,
            comment.green()
        );
        println!();
    }

    // ========== DeleteJsonKey implementation ==========

    fn execute_delete_json_key(context: &MessageContext) -> anyhow::Result<OperationResult> {
        let file_path = Path::new(context.file_path());
        let key = context.key.as_str();

        let mut editor = JsonEditor::open(file_path)?;
        let deleted = editor.delete_keys(&[key])?;
        if deleted > 0 {
            editor.save()?;
            return Ok(OperationResult::Applied);
        }

        Ok(OperationResult::Noop)
    }

    pub(crate) fn apply_insert_comment_ops(ops: &[Operation]) -> anyhow::Result<usize> {
        if ops.is_empty() {
            return Ok(0);
        }

        let mut file_path: Option<&str> = None;
        let mut groups: Vec<InsertGroup> = Vec::new();

        for op in ops {
            if let Operation::InsertComment { context, comment } = op {
                let op_path = context.file_path();
                if let Some(existing) = file_path {
                    if existing != op_path {
                        anyhow::bail!("apply_insert_comment_ops expects ops from a single file");
                    }
                } else {
                    file_path = Some(op_path);
                }

                let kind = directive_kind(comment);
                let line = context.line();
                let style = context.comment_style;

                if let Some(group) = groups
                    .iter_mut()
                    .find(|g| g.line == line && g.comment_style == style && g.kind == kind)
                {
                    group.comments.push(comment.clone());
                } else {
                    groups.push(InsertGroup {
                        line,
                        comment_style: style,
                        kind,
                        comments: vec![comment.clone()],
                    });
                }
            }
        }

        let file_path = match file_path {
            Some(path) => path,
            None => return Ok(0),
        };

        groups.sort_by(|a, b| b.line.cmp(&a.line));

        let content = fs::read_to_string(file_path)?;
        let newline = if content.contains("\r\n") {
            "\r\n"
        } else {
            "\n"
        };
        let had_trailing_newline = content.ends_with(newline);
        let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();

        let mut changes_applied = 0;
        let mut changed = false;

        for group in groups {
            let target_idx = group.line.saturating_sub(1);
            let indentation: String = lines
                .get(target_idx)
                .map(|s| s.chars().take_while(|c| c.is_whitespace()).collect())
                .unwrap_or_default();

            let existing_idx = if target_idx > 0
                && target_idx - 1 < lines.len()
                && looks_like_glot_comment(&lines[target_idx - 1])
            {
                Some(target_idx - 1)
            } else {
                None
            };

            if let Some(idx) = existing_idx
                && let Some(merged_comment) = build_merged_comment(&group, Some(&lines[idx]))
            {
                let merge_indentation: String = lines[idx]
                    .chars()
                    .take_while(|c| c.is_whitespace())
                    .collect();
                let merged_line = format!("{}{}", merge_indentation, merged_comment);

                if lines[idx].trim() != merged_line.trim() {
                    lines[idx] = merged_line;
                    changes_applied += 1;
                    changed = true;
                }
                continue;
            }

            if let Some(merged_comment) = build_merged_comment(&group, None) {
                let comment_line = format!("{}{}", indentation, merged_comment);
                let insert_idx = target_idx.min(lines.len());
                lines.insert(insert_idx, comment_line);
                changes_applied += 1;
                changed = true;
            } else {
                let insert_idx = target_idx.min(lines.len());
                for comment in group.comments.iter().rev() {
                    let comment_line = format!("{}{}", indentation, comment);
                    lines.insert(insert_idx, comment_line);
                    changes_applied += 1;
                    changed = true;
                }
            }
        }

        if changed {
            let mut new_content = lines.join(newline);
            if had_trailing_newline {
                new_content.push_str(newline);
            }
            fs::write(file_path, new_content)?;
        }

        Ok(changes_applied)
    }

    fn preview_delete_json_key(context: &MessageContext) {
        let file_path = context.file_path();
        let line = context.line();
        let key = &context.key;
        let value = &context.value;

        // Clickable location
        println!("  {} {}:{}", "-->".blue(), file_path, line);

        // Key and value
        println!("     {}", "|".blue());
        println!(
            " {:>3} {} \"{}\": \"{}\"",
            line.to_string().blue(),
            "|".blue(),
            key,
            value
        );

        // Deletion indicator
        println!("  {} delete key \"{}\"", "-".red().bold(), key.red());
        println!();
    }
}

fn parse_comment_directive(comment: &str) -> Option<Directive> {
    let text = strip_comment_markers(comment)?;
    Directive::parse(text)
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum DirectiveKind {
    DisableNextLine,
    MessageKeys,
    Other,
}

#[derive(Debug, Clone)]
struct InsertGroup {
    line: usize,
    comment_style: CommentStyle,
    kind: DirectiveKind,
    comments: Vec<String>,
}

fn directive_kind(comment: &str) -> DirectiveKind {
    match parse_comment_directive(comment) {
        Some(Directive::DisableNextLine { .. }) => DirectiveKind::DisableNextLine,
        Some(Directive::MessageKeys(_)) => DirectiveKind::MessageKeys,
        _ => DirectiveKind::Other,
    }
}

fn strip_comment_markers(comment: &str) -> Option<&str> {
    let trimmed = comment.trim();
    if let Some(rest) = trimmed.strip_prefix("//") {
        return Some(rest.trim());
    }
    if trimmed.starts_with("{/*") && trimmed.ends_with("*/}") {
        let inner = &trimmed[3..trimmed.len().saturating_sub(3)];
        return Some(inner.trim());
    }
    None
}

fn detect_comment_style(line: &str) -> Option<CommentStyle> {
    let trimmed = line.trim_start();
    if trimmed.starts_with("//") {
        return Some(CommentStyle::Js);
    }
    if trimmed.starts_with("{/*") {
        return Some(CommentStyle::Jsx);
    }
    None
}

fn find_mergeable_comment_line(lines: &[String], target_line_idx: usize) -> Option<usize> {
    if target_line_idx < lines.len() && looks_like_glot_comment(&lines[target_line_idx]) {
        return Some(target_line_idx);
    }
    if target_line_idx > 0 && looks_like_glot_comment(&lines[target_line_idx - 1]) {
        return Some(target_line_idx - 1);
    }
    None
}

fn looks_like_glot_comment(line: &str) -> bool {
    if let Some(text) = strip_comment_markers(line) {
        return text.trim_start().starts_with("glot-");
    }
    false
}

fn build_merged_comment(group: &InsertGroup, existing_line: Option<&str>) -> Option<String> {
    let mut style = group.comment_style;
    if let Some(line) = existing_line
        && directive_kind(line) != group.kind
    {
        return None;
    }
    let existing_directive = existing_line.and_then(parse_comment_directive);
    if let Some(line) = existing_line
        && let Some(detected) = detect_comment_style(line)
    {
        style = detected;
    }

    match group.kind {
        DirectiveKind::DisableNextLine => {
            let mut merged = std::collections::HashSet::new();

            if let Some(Directive::DisableNextLine { rules }) = existing_directive {
                merged.extend(rules.iter().copied());
            }

            for comment in &group.comments {
                if let Some(Directive::DisableNextLine { rules }) = parse_comment_directive(comment)
                {
                    merged.extend(rules.iter().copied());
                }
            }

            if merged.is_empty() {
                return None;
            }
            Some(format_disable_next_line(&merged, style))
        }
        DirectiveKind::MessageKeys => {
            let mut patterns: Vec<String> = Vec::new();
            let mut seen = std::collections::HashSet::new();

            if let Some(line) = existing_line
                && let Some(existing_patterns) = extract_message_key_patterns(line)
            {
                for pattern in existing_patterns {
                    if seen.insert(pattern.clone()) {
                        patterns.push(pattern);
                    }
                }
            }

            for comment in &group.comments {
                if let Some(comment_patterns) = extract_message_key_patterns(comment) {
                    for pattern in comment_patterns {
                        if seen.insert(pattern.clone()) {
                            patterns.push(pattern);
                        }
                    }
                }
            }

            if patterns.is_empty() {
                return None;
            }

            Some(format_message_keys(&patterns, style))
        }
        DirectiveKind::Other => None,
    }
}

fn merge_directives(
    existing_comment: &str,
    new_comment: &str,
    existing: &Directive,
    new: &Directive,
    comment_style: CommentStyle,
) -> Option<String> {
    match (existing, new) {
        (Directive::DisableNextLine { rules: a }, Directive::DisableNextLine { rules: b }) => {
            let mut merged = a.clone();
            merged.extend(b.iter().copied());
            Some(format_disable_next_line(&merged, comment_style))
        }
        (Directive::MessageKeys(_), Directive::MessageKeys(_)) => {
            let existing_patterns = extract_message_key_patterns(existing_comment)?;
            let new_patterns = extract_message_key_patterns(new_comment)?;
            let merged = merge_message_key_patterns(&existing_patterns, &new_patterns);
            Some(format_message_keys(&merged, comment_style))
        }
        _ => None,
    }
}

fn extract_message_key_patterns(comment: &str) -> Option<Vec<String>> {
    let text = strip_comment_markers(comment)?;
    if !text.trim_start().starts_with("glot-message-keys") {
        return None;
    }
    let patterns = extract_quoted_strings(text);
    if patterns.is_empty() {
        return None;
    }
    Some(patterns)
}

fn extract_quoted_strings(text: &str) -> Vec<String> {
    let mut patterns = Vec::new();
    let mut in_quote = false;
    let mut current = String::new();

    for ch in text.chars() {
        if in_quote {
            if ch == '"' {
                patterns.push(current.clone());
                current.clear();
                in_quote = false;
            } else {
                current.push(ch);
            }
        } else if ch == '"' {
            in_quote = true;
        }
    }

    patterns
}

fn merge_message_key_patterns(existing: &[String], new: &[String]) -> Vec<String> {
    let mut merged: Vec<String> = Vec::new();
    let mut seen = std::collections::HashSet::new();

    for pattern in existing {
        if seen.insert(pattern.clone()) {
            merged.push(pattern.clone());
        }
    }

    for pattern in new {
        if seen.insert(pattern.clone()) {
            merged.push(pattern.clone());
        }
    }

    merged
}

fn format_disable_next_line(
    rules: &std::collections::HashSet<SuppressibleRule>,
    style: CommentStyle,
) -> String {
    let suffix = SuppressibleRule::format_rules(rules);
    let directive = if suffix.is_empty() {
        "glot-disable-next-line".to_string()
    } else {
        format!("glot-disable-next-line {}", suffix)
    };
    match style {
        CommentStyle::Js => format!("// {}", directive),
        CommentStyle::Jsx => format!("{{/* {} */}}", directive),
    }
}

fn format_message_keys(patterns: &[String], style: CommentStyle) -> String {
    let quoted: Vec<String> = patterns.iter().map(|p| format!("\"{}\"", p)).collect();
    let directive = format!("glot-message-keys {}", quoted.join(", "));
    match style {
        CommentStyle::Js => format!("// {}", directive),
        CommentStyle::Jsx => format!("{{/* {} */}}", directive),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::{CommentStyle, MessageLocation, SourceLocation};
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_operation_insert_comment() {
        let loc = SourceLocation::new("./src/app.tsx", 10, 5);
        let ctx = SourceContext::new(loc, "const x = \"Hello\";", CommentStyle::Js);
        let op = Operation::InsertComment {
            context: ctx,
            comment: "// glot-disable-next-line hardcoded".to_string(),
        };

        match &op {
            Operation::InsertComment { context, comment } => {
                assert_eq!(context.file_path(), "./src/app.tsx");
                assert_eq!(comment, "// glot-disable-next-line hardcoded");
            }
            _ => panic!("Expected InsertComment"),
        }
    }

    #[test]
    fn test_operation_delete_json_key() {
        let loc = MessageLocation::new("./messages/en.json", 5, 3);
        let ctx = MessageContext::new(loc, "Common.unused", "Unused value");
        let op = Operation::DeleteJsonKey { context: ctx };

        match &op {
            Operation::DeleteJsonKey { context } => {
                assert_eq!(context.file_path(), "./messages/en.json");
                assert_eq!(context.key, "Common.unused");
            }
            _ => panic!("Expected DeleteJsonKey"),
        }
    }

    #[test]
    fn test_insert_comment_merges_disable_existing() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("app.tsx");
        let content = "// glot-disable-next-line hardcoded\nconst x = \"Hello\";\n";
        fs::write(&file_path, content).unwrap();

        let loc = SourceLocation::new(file_path.to_string_lossy(), 2, 1);
        let ctx = SourceContext::new(loc, "const x = \"Hello\";", CommentStyle::Js);
        let op = Operation::InsertComment {
            context: ctx,
            comment: "// glot-disable-next-line untranslated".to_string(),
        };

        let _ = op.execute().unwrap();

        let updated = fs::read_to_string(&file_path).unwrap();
        let expected = "// glot-disable-next-line hardcoded untranslated\nconst x = \"Hello\";\n";
        assert_eq!(updated, expected);
    }

    #[test]
    fn test_insert_comment_merges_message_keys_existing() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("app.tsx");
        let content = "// glot-message-keys \"a\"\nconst x = t(key);\n";
        fs::write(&file_path, content).unwrap();

        let loc = SourceLocation::new(file_path.to_string_lossy(), 2, 1);
        let ctx = SourceContext::new(loc, "const x = t(key);", CommentStyle::Js);
        let op = Operation::InsertComment {
            context: ctx,
            comment: "// glot-message-keys \"b\"".to_string(),
        };

        let _ = op.execute().unwrap();

        let updated = fs::read_to_string(&file_path).unwrap();
        let expected = "// glot-message-keys \"a\", \"b\"\nconst x = t(key);\n";
        assert_eq!(updated, expected);
    }

    #[test]
    fn test_insert_comment_merges_multiple_inserts_same_line() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("app.tsx");
        let content = "const x = \"Hello\";\n";
        fs::write(&file_path, content).unwrap();

        let loc = SourceLocation::new(file_path.to_string_lossy(), 1, 1);
        let ctx = SourceContext::new(loc, "const x = \"Hello\";", CommentStyle::Js);

        let op1 = Operation::InsertComment {
            context: ctx.clone(),
            comment: "// glot-disable-next-line hardcoded".to_string(),
        };
        let _ = op1.execute().unwrap();

        let op2 = Operation::InsertComment {
            context: ctx,
            comment: "// glot-disable-next-line untranslated".to_string(),
        };
        let _ = op2.execute().unwrap();

        let updated = fs::read_to_string(&file_path).unwrap();
        let expected = "// glot-disable-next-line hardcoded untranslated\nconst x = \"Hello\";\n";
        assert_eq!(updated, expected);
    }

    #[test]
    fn test_insert_comment_merges_message_keys_jsx() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("app.tsx");
        let content = "{/* glot-message-keys \"a\" */}\nconst x = t(key);\n";
        fs::write(&file_path, content).unwrap();

        let loc = SourceLocation::new(file_path.to_string_lossy(), 2, 1);
        let ctx = SourceContext::new(loc, "const x = t(key);", CommentStyle::Jsx);
        let op = Operation::InsertComment {
            context: ctx,
            comment: "{/* glot-message-keys \"b\" */}".to_string(),
        };

        let _ = op.execute().unwrap();

        let updated = fs::read_to_string(&file_path).unwrap();
        let expected = "{/* glot-message-keys \"a\", \"b\" */}\nconst x = t(key);\n";
        assert_eq!(updated, expected);
    }
}
