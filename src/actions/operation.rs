//! Low-level file operations.
//!
//! Operations are the primitive building blocks for file modifications.
//! There are only two types:
//! - `InsertComment`: Insert a comment line above a source location
//! - `DeleteJsonKey`: Delete a key from a JSON file
//!
//! Each operation knows how to execute itself and preview itself.

use colored::Colorize;
use unicode_width::UnicodeWidthStr;

use crate::analysis::{MessageContext, SourceContext};

/// A low-level file operation.
///
/// Operations are generated by Actions. Each operation can execute itself
/// (modify files) or preview itself (display what would be done).
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Operation {
    /// Insert a comment line above a source location.
    InsertComment {
        context: SourceContext,
        comment: String,
    },
    /// Delete a key from a JSON file.
    DeleteJsonKey { context: MessageContext },
}

impl Operation {
    /// Execute this operation (modify files).
    pub fn execute(&self) -> anyhow::Result<()> {
        match self {
            Operation::InsertComment { context, comment } => {
                Self::execute_insert_comment(context, comment)
            }
            Operation::DeleteJsonKey { context } => Self::execute_delete_json_key(context),
        }
    }

    /// Preview this operation (display what would be done).
    pub fn preview(&self) {
        match self {
            Operation::InsertComment { context, comment } => {
                Self::preview_insert_comment(context, comment);
            }
            Operation::DeleteJsonKey { context } => {
                Self::preview_delete_json_key(context);
            }
        }
    }

    // ========== InsertComment implementation ==========

    fn execute_insert_comment(context: &SourceContext, comment: &str) -> anyhow::Result<()> {
        use std::fs;

        let file_path = context.file_path();
        let content = fs::read_to_string(file_path)?;

        // Detect original newline style
        let newline = if content.contains("\r\n") {
            "\r\n"
        } else {
            "\n"
        };
        let had_trailing_newline = content.ends_with(newline);

        let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();

        // Get indentation from the target line
        let target_line_idx = context.line().saturating_sub(1);
        let indentation: String = lines
            .get(target_line_idx)
            .map(|s| s.chars().take_while(|c| c.is_whitespace()).collect())
            .unwrap_or_default();

        // Insert comment above the target line
        let comment_line = format!("{}{}", indentation, comment);
        if target_line_idx <= lines.len() {
            lines.insert(target_line_idx, comment_line);
        }

        // Write back
        let mut new_content = lines.join(newline);
        if had_trailing_newline {
            new_content.push_str(newline);
        }

        fs::write(file_path, new_content)?;
        Ok(())
    }

    fn preview_insert_comment(context: &SourceContext, comment: &str) {
        let file_path = context.file_path();
        let line = context.line();
        let col = context.col();
        let source_line = &context.source_line;

        // Clickable location
        println!("  {} {}:{}:{}", "-->".blue(), file_path, line, col);

        // Source context
        println!("     {}", "|".blue());
        println!(
            " {:>3} {} {}",
            line.to_string().blue(),
            "|".blue(),
            source_line
        );

        // Caret
        let prefix: String = source_line.chars().take(col.saturating_sub(1)).collect();
        let caret_padding = UnicodeWidthStr::width(prefix.as_str());
        println!(
            "     {} {:>padding$}{}",
            "|".blue(),
            "",
            "^".green(),
            padding = caret_padding
        );

        // Comment to be inserted
        let indentation: String = source_line
            .chars()
            .take_while(|c| c.is_whitespace())
            .collect();
        println!(
            "  {} {}{}",
            "+".green().bold(),
            indentation,
            comment.green()
        );
        println!();
    }

    // ========== DeleteJsonKey implementation ==========

    fn execute_delete_json_key(context: &MessageContext) -> anyhow::Result<()> {
        use crate::json_editor::JsonEditor;
        use std::path::Path;

        let file_path = Path::new(context.file_path());
        let key = context.key.as_str();

        let mut editor = JsonEditor::open(file_path)?;
        editor.delete_keys(&[key])?;
        editor.save()?;

        Ok(())
    }

    fn preview_delete_json_key(context: &MessageContext) {
        let file_path = context.file_path();
        let line = context.line();
        let key = &context.key;
        let value = &context.value;

        // Clickable location
        println!("  {} {}:{}", "-->".blue(), file_path, line);

        // Key and value
        println!("     {}", "|".blue());
        println!(
            " {:>3} {} \"{}\": \"{}\"",
            line.to_string().blue(),
            "|".blue(),
            key,
            value
        );

        // Deletion indicator
        println!("  {} delete key \"{}\"", "-".red().bold(), key.red());
        println!();
    }
}

#[cfg(test)]
mod tests {
    use crate::actions::operation::*;
    use crate::analysis::{CommentStyle, MessageLocation, SourceLocation};

    #[test]
    fn test_operation_insert_comment() {
        let loc = SourceLocation::new("./src/app.tsx", 10, 5);
        let ctx = SourceContext::new(loc, "const x = \"Hello\";", CommentStyle::Js);
        let op = Operation::InsertComment {
            context: ctx,
            comment: "// glot-disable-next-line hardcoded".to_string(),
        };

        match &op {
            Operation::InsertComment { context, comment } => {
                assert_eq!(context.file_path(), "./src/app.tsx");
                assert_eq!(comment, "// glot-disable-next-line hardcoded");
            }
            _ => panic!("Expected InsertComment"),
        }
    }

    #[test]
    fn test_operation_delete_json_key() {
        let loc = MessageLocation::new("./messages/en.json", 5, 3);
        let ctx = MessageContext::new(loc, "Common.unused", "Unused value");
        let op = Operation::DeleteJsonKey { context: ctx };

        match &op {
            Operation::DeleteJsonKey { context } => {
                assert_eq!(context.file_path(), "./messages/en.json");
                assert_eq!(context.key, "Common.unused");
            }
            _ => panic!("Expected DeleteJsonKey"),
        }
    }
}
